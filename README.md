# Расчет геометрии объектов с помощью стереокамер

## Обзор

В этом репозитории собраны решения команды **PixelPoint** по кейсу измерению геометрии объектов с использованием стереокамеры. Решение включает несколько ключевых модулей и шагов, основные компоненты включают:

1. **Пользовательский интерфейс**
1. **Генерация синтетического датасета**
1. **Калибровка камеры**
1. **Ректификация изображений и удаление искажений**
1. **Расчёт диспаритета**
1. **Создание карты глубины**
1. **Реконструкция 3D объекта**

## Установка проекта

Все необходимые зависимости и инструкции по сборке определены в файле `pyproject.toml`. Чтобы установить модуль вместе с его зависимостями, выполните следующую команду:

```bash
pip install .
```

Это автоматически установит все необходимые пакеты.

## Интерфейс

Эта часть проекта представляет собою пользовательский интерфейс, в котором пользователь вводит данные о камере, расстоянии между камерами, загружает либо две фотографии детали с разных ракурсов, либо полноценную 3д модель. После нажатия на кнопку `Upload and Process` на данном этапе будут выставляться параметры камеры и выводиться результат.

**Запуск интерфейса:**

```bash
run-app --host 0.0.0.0 --port 8000
```

Перейдите по адресу, указанному в консоли, чтобы открыть интерфейс.

## Генерация синтетических изображений

Для генерации изображений для обучения модели используется графический редактор Blender, в котором присутствует возможность задавать собственные скрипты для создания и рендера сцены.

**Установка Blender:**

```bash
wget https://download.blender.org/release/Blender3.6/blender-3.6.0-linux-x64.tar.xz
tar -xvf blender-3.6.0-linux-x64.tar.xz
rm blender-3.6.0-linux-x64.tar.xz
```

**Генерация изображений:**

Скрипт для генерации изображений лежит по пути scripts/render.sh. В нем необходимо указать путь до объекта для рендера и директорию, куда сохранить сгенерированные изображения.

После запуска скрипта должна получится следующая структура:

```
- save_dir
    - pair_0
        - image_left.png
        - image_right.png
    - pair_1
        - image_left.png
        - image_right.png
    ...
```

## Калибровка камеры

Калибровка камеры включает определение внутренних и внешних параметров:

- `CM` - внутрення матрица камеры
- `dist` - вектор коэффициентов искажений
- `R` - матрица относительного вращение между системами координат первой и второй камер
- `T` - относительное смещение между двумя камерами
- `E` - essential matrix - кодирует относительное вращение и перемещение, определяя эпиполярную геометрию
- `F` - фундаментальная матрица определяет эпиполярные линии, связывая соответствующие точки на двух изображениях

Было реализовано 3 метода для калибровки стереокамеры:

1. **Маркерные точки** (`calibration_markers.py`) - Калибровка с маркерными точками
1. **Шахматная доска** (`calibration_chessboard.py`) - Калибровка с шахматной доской
1. **Прямой матричный расчёт** (`calibration_calculation.py`) - Прямой расчёт матриц параметров камер

**Пример запуска**

```bash
calibration-chessboard --images_folder ./chessboard_images --square_size 0.01 --chessboard_size 7x7 --output_file calibration_params.json
```

**Пайплайны**

- [Jupyter блокнот](../../../notebooks/calibration/calibration_real.ipynb) с пайплайном для калибровки стерео-камеры на основе реальных калибровочных изображений с маркерными досками
- [Jupyter блокнот](../../../notebooks/calibration/calibration_synthetic.ipynb)  с пайплоном для калибровки стерео-камеры на основе синтетических калибровочных изображений с шахматными досками

Для подробных инструкций и методов калибровки, см. [README модуля калибровки](src/pixelpoint/calibration/README.md).

## Детекторы, дескрипторы и матчеры характеристических точек

Задачу сопоставления изображений можно решать разными способами. Одним из подходов является использование нейросетевых структур для нахождения, описания и сопоставления ключевых точек.

В ходе работы были рассматрены и реализованы различные детекторы характеристических точек, включая ORB, SIFT и нейросетевой SuperPoint. Также был опробован метод матчинга SuperGlue.

Был написал модуль для предоставления инструментов для обнаружения признаков с помощью различных детекторов: ORB, SIFT и SuperPoint. Он включает следующие компоненты:

- `orb_sift_detectors.py`: Реализует извлечение ключевых точек и дескрипторов с помощью ORB и SIFT.
- `superpoint_detectors.py`: Использует модель SuperPoint для извлечения ключевых точек и дескрипторов.

**Пример запуска**

```bash
superpoint-detector --image1 dog_left.jpg --image2 dog.right.jpg
```

[Jupyter блокнот](../../../notebooks/feature_detection/feature_detection.ipynb) с подробным описанием методов обнаружения характеристических точек на основе ORB, SIFT и SuperPoint с их сравнением.

Более подробная информация о работе модуля и инструкциях по его использованию описана в [README модуля обнаружения характеристических точек](src/pixelpoint/feature_detection/README.md).

Из-за того что такие подходы как Superpoint требуют значительных вычислительных ресурсов, в нашем решении мы используем классические алгоритмы компьютерного зрения, которые эффективно используют стереоскопический эффект и являются менее ресурсоемкими. Мы ориентируемся на алгоритмы матчинга по ректифицированным изображениям: `stereoBM` и `stereoSGBM`

## Расчет расстояний на синтетических данных

**Интерфейс для расчета расстояний**
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1m_N_agT3jzgnxFM-_Rfe5rKSiyjdEoJH?usp=sharing)

Для подсчета расстояний на синтетических данных сначала необходимо откалибровать камеру. Далее строится облако точек в котором находятся нужные нам точки, отмеченные пользователем, или найденные с помощью NN/CV по паттерну. В конечном итоге расстояние считается как норма вектора между двумя точками в Евклидовом пространстве.

**Калибровка камеры на синтетических данных**

Калибровка проводилась по 50 парам стереоизображений, сгенерированных с помощью [render_chessboard.py](src/pixelpoint/calibration/render_chessboard.py), с определенными параметрами камеры, объектива и конфигурации оптической системы.

Используемая шахматная доска:

<img width="200" height="200" alt="checkerboard" src="https://github.com/user-attachments/assets/33212fd1-8e82-45c0-bbc4-dea33a18d3ee">

Исходный код калибровки находится в [calibrate_chessboard.py](src/pixelpoint/calibration/calibrate_chessboard.py).
Вычисленные внутренние и внешние параметры, используются затем в пайплайне, описанном ниже.

**Расчёт диспаритета и карты глубины**

Подсчет диспаритета осуществляется с помощью функции StereoBM_create Для подсчета карты глубины используется ректификация, позволяющая посчитать матрицу отображения диспаритета в глубину Нахождение эпиполярных линий также ускоряет подсчет карты глубины.

Пример карты диспаритета (чёрно-белое изображение):

<img width="1263" alt="disparity-map" src="https://github.com/user-attachments/assets/1e0817e4-a242-4f89-9399-e41ad810376f">

**Реконструкция 3D облака точек**

C помощью построенной карты диспаритета и глубины вычисляется облако точек. С помощью только лишь двух фотографий можно определить примерные очертания 3D модели по двум сторонам, но никак не по всему периметру, поэтому при генерации 3D облака точек, оно представляет собой пирамидальную структуру. Это не полноценная 3D модель, но её аналог.

После построения облака точек можно посмотреть различные его 2D-проекции под разными углами:

<img width="500" alt="point-cloud-projection" src="https://github.com/user-attachments/assets/d8f95a7e-f4fa-4e3b-9a1a-fa610990f53f">

**Выделение нужных точек, и подсчет расстояния между ними**

Сейчас реализован функционал, с помощью которого можно отметить прямо в jupyter-ноутбуке две любые точки на изображении, и посчитать между ними расстояние в 3D В качестве интерфейса взаимодействия используется jupyter notebook в Google Collab.

Пример выбора и измерения точек:

<img width="500" alt="distance-measurement" src="https://github.com/user-attachments/assets/a8ba0dc4-8b48-4d51-a50f-0e78f4d40b2a">

## Команда

- Александр Кудрявцев
- Тимур Ильясов
- Денис Кирбаба
- Леонид Алхименков
- Максим Чупров
